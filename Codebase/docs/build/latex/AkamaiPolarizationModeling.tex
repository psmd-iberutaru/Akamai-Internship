%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{0}



\title{Akamai Polarization Modeling Documentation}
\date{Aug 08, 2018}
\release{1.0}
\author{Kyubey}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}


This is the documentation of a simulation program that simulates observations of magnetic morphologies of star-forming regions. Modeling arbitrary and custom 3D cloud shape geometries, integrating along sightlines over user-inputted magnetic fields, density profiles, and polarization functions.

Overall, this codebase would return the user back the values of \sphinxhref{https://en.wikipedia.org/wiki/Stokes\_parameters}{Stokes parameters} for the given object that they inputted. It will also, by default, plot the data to contour maps in the form of heat maps that visually describe the object that the user input into the simulation.

Written apart of a \sphinxhref{https://akamaihawaii.org/}{Akamai Workforce Initiative} Summer internship.

Written in \sphinxhref{https://www.python.org/}{Python 3.6}, this package also relies on the following external Python packages:
\begin{itemize}
\item {} 
\sphinxhref{http://www.numpy.org/}{Numpy}

\item {} 
\sphinxhref{https://www.scipy.org/}{Scipy}

\item {} 
\sphinxhref{http://www.sympy.org/en/index.html}{Sympy}

\item {} 
\sphinxhref{https://matplotlib.org/}{Matplotlib}

\item {} 
\sphinxhref{http://www.astropy.org/}{Astropy}

\end{itemize}

However, it is suggested to use a standard \sphinxhref{https://www.anaconda.com/download/}{Anaconda Distribution} instead of manually installing the packages in the event of conflicts.


\chapter{Quickstart}
\label{\detokenize{quickstart:quickstart}}\label{\detokenize{quickstart::doc}}
This is a brief quickstart introduction to this module/code. This highlights the main purposes of the code, providing examples and other references.

It is assumed that the program/code has been installed along with its inherent dependencies. If not, then consult the main page for more information.

The core of this module is the {\hyperref[\detokenize{model_observing:model_observing.ObservingRun}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ObservingRun}}}}} object. This object, as the name implies, is the class that acts as the observation run of the simulation.

In order to make the {\hyperref[\detokenize{model_observing:model_observing.ObservingRun}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ObservingRun}}}}} object, we first need two other objects: {\hyperref[\detokenize{model_observing:model_observing.ProtostarModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ProtostarModel}}}}} and {\hyperref[\detokenize{model_observing:model_observing.Sightline}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Sightline}}}}} objects.

First, let us make the {\hyperref[\detokenize{model_observing:model_observing.ProtostarModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ProtostarModel}}}}} object. First off there are five things that we need to provide in order to make such an object (although two are optional).


\chapter{Active\_Codebase}
\label{\detokenize{modules:active-codebase}}\label{\detokenize{modules::doc}}

\section{Backend package}
\label{\detokenize{Backend:backend-package}}\label{\detokenize{Backend::doc}}

\subsection{Submodules}
\label{\detokenize{Backend:submodules}}

\subsubsection{Backend.Ewertowski\_Basu\_2013 module}
\label{\detokenize{Backend.Ewertowski_Basu_2013:module-Backend.Ewertowski_Basu_2013}}\label{\detokenize{Backend.Ewertowski_Basu_2013:backend-ewertowski-basu-2013-module}}\label{\detokenize{Backend.Ewertowski_Basu_2013::doc}}\index{Backend.Ewertowski\_Basu\_2013 (module)}
This file is most of the backend functionality that is required for the
more important functions within this module that relates to the paper by
Bartek Ewertowshi and Shantanu Basu on their work in 2013 on “A Mathematical
Model for an Hourglass Magnetic Field”.

The functions here are almost explicitly for magnetic field functions.
\index{Ewer\_Basu\_\_B\_r() (in module Backend.Ewertowski\_Basu\_2013)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Backend.Ewertowski_Basu_2013:Backend.Ewertowski_Basu_2013.Ewer_Basu__B_r}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Backend.Ewertowski\_Basu\_2013.}}\sphinxbfcode{\sphinxupquote{Ewer\_Basu\_\_B\_r}}}{\emph{r}, \emph{z}, \emph{h}, \emph{k\_array}, \emph{disk\_radius}}{}
An implementation of Eq 45 of Ewertiwski \& Basu 2013.

This implements equation 45 of Ewertiwski \& Basu 2013. The k\_array (values
of k) determine the number of summation terms that will be computed. The
value of r is with respect to the cylindrical cordinate system.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{r}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The input values of the radial direction for the equation.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{z}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The input values of the polar direction for the equation.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{h}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} A free parameter as dictated by the paper.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{k\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The list of k coefficient values for the summation in Eq 45.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{disk\_radius}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} The radius of the protoplanetary disk. Relevent for the hourglass
magnetic field generated by this paper.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{Bfield\_r} \textendash{} The value of the magnetic field in the r-axial direction.

\item[{Return type}] \leavevmode
ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{Ewer\_Basu\_\_B\_z() (in module Backend.Ewertowski\_Basu\_2013)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Backend.Ewertowski_Basu_2013:Backend.Ewertowski_Basu_2013.Ewer_Basu__B_z}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Backend.Ewertowski\_Basu\_2013.}}\sphinxbfcode{\sphinxupquote{Ewer\_Basu\_\_B\_z}}}{\emph{r}, \emph{z}, \emph{h}, \emph{k\_array}, \emph{disk\_radius}, \emph{uniform\_B0}}{}
An implementation of Eq 46 of Ewertiwski \& Basu 2013.

This implements equation 46 of Ewertiwski \& Basu 2013. The k\_array (values
of k) determine the number of summation terms that will be computed. The
value of r is with respect to the cylindrical cordinate system.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{r}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The input values of the radial direction for the equation.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{z}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The input values of the polar direction for the equation.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{h}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} A free parameter as dictated by the paper.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{k\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The list of k coefficient values for the summation in Eq 45.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{disk\_radius}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} The radius of the protoplanetary disk. Relevent for the hourglass
magnetic field generated by this paper.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{uniform\_B0}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} The magnitude of the background magnetic field.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{Bfield\_z} \textendash{} The value of the magnetic field in the z-axial direction.

\item[{Return type}] \leavevmode
ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{Ewer\_Basu\_\_eigenvalues() (in module Backend.Ewertowski\_Basu\_2013)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Backend.Ewertowski_Basu_2013:Backend.Ewertowski_Basu_2013.Ewer_Basu__eigenvalues}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Backend.Ewertowski\_Basu\_2013.}}\sphinxbfcode{\sphinxupquote{Ewer\_Basu\_\_eigenvalues}}}{\emph{index\_m}, \emph{disk\_radius}}{}
This is the values of the eigenvalues of some integer index m.

This computes the eigenvalues (see Equation 28 of Ewer \& Basu 2013) of
the normalized Green functions for the hourglass magnetic field solution.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{index\_m}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} This is the index of the eigenvalue, it links up to the index of the
positive root of a Bessel function of the first kind of order 1.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{disk\_radius}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} The radius of the protoplanetary disk. Relevent for the hourglass
magnetic field generated by this paper.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{eigenvalue} \textendash{} The value of the corresponding eigenvalue given the parameters.

\item[{Return type}] \leavevmode
\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{float}

\end{description}\end{quote}

\end{fulllineitems}

\index{bessel\_zeros() (in module Backend.Ewertowski\_Basu\_2013)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Backend.Ewertowski_Basu_2013:Backend.Ewertowski_Basu_2013.bessel_zeros}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Backend.Ewertowski\_Basu\_2013.}}\sphinxbfcode{\sphinxupquote{bessel\_zeros}}}{\emph{order}, \emph{index}}{}
Returns a Bessel zero given the function’s order and zero index.

This function is a wrapper around Scipy’s Bessel function zero generator.
For some reason, the Scipy function returns all zeros between the given
number and the first zero. This function extracts only the wanted zero
given the index.

This is for Bessel functions of the first kind.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{order}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} The integer order of the Bessel function of the first kind.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{index}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} The zero’s index that is desired.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{zero} \textendash{} The value of the zero at the given index of the given Bessel function.

\item[{Return type}] \leavevmode
\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{float}

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{Backend.astronomical\_coordinates module}
\label{\detokenize{Backend.astronomical_coordinates:module-Backend.astronomical_coordinates}}\label{\detokenize{Backend.astronomical_coordinates:backend-astronomical-coordinates-module}}\label{\detokenize{Backend.astronomical_coordinates::doc}}\index{Backend.astronomical\_coordinates (module)}
This file is mostly the calculations required for corrections to the
astrophysical coordinate system, and any calculations required for such is
recorded here.
\index{angle\_normalization\_0\_2pi() (in module Backend.astronomical\_coordinates)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Backend.astronomical_coordinates:Backend.astronomical_coordinates.angle_normalization_0_2pi}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Backend.astronomical\_coordinates.}}\sphinxbfcode{\sphinxupquote{angle\_normalization\_0\_2pi}}}{\emph{angle}}{}
Automatically normalize angle value(s) to the range of 0-2pi.

This function relies on modular arithmetic.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{angle}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The angles to be converted

\item[{Returns}] \leavevmode
\sphinxstylestrong{normalized\_angles} \textendash{} The angles after being normalized to be between 0-2pi.

\item[{Return type}] \leavevmode
ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{auto\_ra\_wrap\_angle() (in module Backend.astronomical\_coordinates)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Backend.astronomical_coordinates:Backend.astronomical_coordinates.auto_ra_wrap_angle}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Backend.astronomical\_coordinates.}}\sphinxbfcode{\sphinxupquote{auto\_ra\_wrap\_angle}}}{\emph{object\_ra\_value}}{}
Automatically calculate the RA wrap value.

Given an input RA, this function automatically calculates the RA wrap
angle to likely be used for an Astropy \sphinxcode{\sphinxupquote{SkyCoord}} object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{object\_ra\_value}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The RA value(s) that will determine the wrap angle(s).

\item[{Returns}] \leavevmode
\sphinxstylestrong{ra\_wrap\_angle} \textendash{} The value of the wrap angle that the function best described.

\item[{Return type}] \leavevmode
ndarray

\end{description}\end{quote}
\paragraph{Notes}

In this function, it assumes that there are only 4 main quadrants. First,
the wrap angle is determined to be either at \(0\) or \(\pi\) depending on the location of the sightline’s RA.

\end{fulllineitems}



\subsubsection{Backend.cloud\_line\_integration module}
\label{\detokenize{Backend.cloud_line_integration:module-Backend.cloud_line_integration}}\label{\detokenize{Backend.cloud_line_integration:backend-cloud-line-integration-module}}\label{\detokenize{Backend.cloud_line_integration::doc}}\index{Backend.cloud\_line\_integration (module)}
This module outlines the math side of the integration functions used. The
cloud line integration computes a line integral along a sightline path,
whereas the bounds of the integration is such that a field is integrated
within the cloud.
\index{cloud\_line\_integral() (in module Backend.cloud\_line\_integration)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Backend.cloud_line_integration:Backend.cloud_line_integration.cloud_line_integral}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Backend.cloud\_line\_integration.}}\sphinxbfcode{\sphinxupquote{cloud\_line\_integral}}}{\emph{field\_function}, \emph{cloud\_equation}, \emph{view\_line\_point}, \emph{box\_width}, \emph{view\_line\_deltas=(1}, \emph{0}, \emph{0)}, \emph{n\_guesses=100}, \emph{integral\_method='scipy'}}{}
Computs the line integral over a field given bounds of a cloud and path.

This function computes the total summation of the line integrals given
a field function that a single sightline passes through, given the
boundary that only the section of the line within a cloud would be
computed as it is the upper and lower bounds for the integral(s).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{field\_function}} (\sphinxstyleliteralemphasis{\sphinxupquote{function}}) \textendash{} The function of the field. Must be three dimensional in the form
\sphinxcode{\sphinxupquote{def f(x,y,z): return a}}. Does not accept non-numerical returns.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cloud\_equation}} (\sphinxstyleliteralemphasis{\sphinxupquote{function}}) \textendash{} The implicit equation of the cloud. Must be \sphinxcode{\sphinxupquote{f(x)}} where
\sphinxcode{\sphinxupquote{f(x) = 0}}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{view\_line\_point}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} Expected in three dimensions. It specifies the point that the viewline
is positioned at in cartesian space.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{box\_width}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} An overestimated value of the size of the cloud along any given axis.
Used for finding locations of intersections of the cloud and sightline.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{view\_line\_deltas}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like; optional}}) \textendash{} Expected in three dimensions. It specifies the linear coefficient that
the sightline travels through space. Defaults to \sphinxcode{\sphinxupquote{(1,0,0)}}, a line
parallel to the x-axis.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_guesses}} (\sphinxstyleliteralemphasis{\sphinxupquote{int; optional}}) \textendash{} An order of magnitude overestimate of the number of intersections
between the cloud and the sightline. Defaults to \sphinxcode{\sphinxupquote{100}}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{integral\_method}} (\sphinxstyleliteralemphasis{\sphinxupquote{string; optional}}) \textendash{} The method of which the integration will be computed. Defaults to
Scipy’s \sphinxhref{https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.quad.html\#scipy.integrate.quad}{\sphinxcode{\sphinxupquote{scipy.integrate.quad()}}}.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{integrated\_value} (\sphinxstyleemphasis{float}) \textendash{} The integrated value of the given field bounded by the sightline and
the shape of the cloud.

\item {} 
\sphinxstylestrong{error} (\sphinxstyleemphasis{float}) \textendash{} The associated error with the integration.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{line\_integral\_boundaries() (in module Backend.cloud\_line\_integration)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Backend.cloud_line_integration:Backend.cloud_line_integration.line_integral_boundaries}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Backend.cloud\_line\_integration.}}\sphinxbfcode{\sphinxupquote{line\_integral\_boundaries}}}{\emph{view\_line\_point}, \emph{cloud\_equation}, \emph{box\_width}, \emph{view\_line\_deltas=(1}, \emph{0}, \emph{0)}, \emph{n\_guesses=100}}{}
Find line integral boundaries given the cloud and sightline.

This function determines the points that intersect the sphere, starting
with it entering and exit. It returns the ranges of points that would
yield line integral boundaries that integrate within the cloud volume.

By default, the cloud equation should be a function such that it returns a
float, \sphinxcode{\sphinxupquote{f(x,y,z)}}, based on implicit shape making: \sphinxcode{\sphinxupquote{f(x,y,z) = 0}}. If
not, it should be at least a string that contains the python syntax
expression of the shape for \sphinxcode{\sphinxupquote{f(x,y,z) = 0}}, i.e., left-hand side of the
equation only.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{view\_line\_point}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} Expected in three dimensions. It specifies the point that the viewline
is positioned at in cartesian space.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cloud\_equation}} (\sphinxstyleliteralemphasis{\sphinxupquote{function}}) \textendash{} The implicit equation of the cloud. Must be \sphinxcode{\sphinxupquote{f(x)}} where
\sphinxcode{\sphinxupquote{f(x) = 0}}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{box\_width}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} An overestimated value of the size of the cloud along any given axis.
Used for finding locations of intersections of the cloud and sightline.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{view\_line\_deltas}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} Expected in three dimensions. It specifies the linear coefficient that
the sightline travels through space. Defaults to \sphinxcode{\sphinxupquote{(1,0,0)}}, a line
parallel to the x-axis.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_guesses}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} An order of magnitude overestimate of the number of intersections
between the cloud and the sightline. Defaults to \sphinxcode{\sphinxupquote{100}}.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{lower\_bounds} (\sphinxstyleemphasis{ndarray}) \textendash{} An array of the lower bound(s) if each integration needed that is
within the cloud along the sightline.

\item {} 
\sphinxstylestrong{upper\_bounds} (\sphinxstyleemphasis{ndarray}) \textendash{} An array of the upper bound(s) if each integration needed that is
within the cloud along the sightline.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{Backend.coordinate\_system\_transformation module}
\label{\detokenize{Backend.coordinate_system_transformation:module-Backend.coordinate_system_transformation}}\label{\detokenize{Backend.coordinate_system_transformation:backend-coordinate-system-transformation-module}}\label{\detokenize{Backend.coordinate_system_transformation::doc}}\index{Backend.coordinate\_system\_transformation (module)}
This file is some side functions that allows for the conversion of cordinate
systems.
\index{cartesian\_to\_cylindrical\_3d() (in module Backend.coordinate\_system\_transformation)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Backend.coordinate_system_transformation:Backend.coordinate_system_transformation.cartesian_to_cylindrical_3d}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Backend.coordinate\_system\_transformation.}}\sphinxbfcode{\sphinxupquote{cartesian\_to\_cylindrical\_3d}}}{\emph{x}, \emph{y}, \emph{z}}{}
Convert cartesian points to cylindrical points.

Convert cartesian coordinate points in 3D to cylindrical coordinate points
in 3D. This function uses the notation convention of ISO 80000-2:2009 and
its related successors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The x values of the points to be transformed.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The y values of the points to be transformed.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{z}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The z values of the points to be transformed.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{rho} (\sphinxstyleemphasis{array\_like}) \textendash{} The rho (radial) values of the points after transformation.

\item {} 
\sphinxstylestrong{phi} (\sphinxstyleemphasis{array\_like}) \textendash{} The phi (angular) values of the points after transformation.

\item {} 
\sphinxstylestrong{z} (\sphinxstyleemphasis{array\_like}) \textendash{} The z (height) values of the points after transformation.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{cartesian\_to\_polar\_2d() (in module Backend.coordinate\_system\_transformation)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Backend.coordinate_system_transformation:Backend.coordinate_system_transformation.cartesian_to_polar_2d}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Backend.coordinate\_system\_transformation.}}\sphinxbfcode{\sphinxupquote{cartesian\_to\_polar\_2d}}}{\emph{x}, \emph{y}}{}
Convert cartesian points to polar points.

Convert cartesian coordinate points in 2D to polar coordinate points in 2D.
This function uses the notation convention of ISO 80000-2:2009 and its
related successors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The x values of the points to be transformed.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The y values of the points to be transformed.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{rho} (\sphinxstyleemphasis{array\_like}) \textendash{} The rho (radial) values of the points after transformation.

\item {} 
\sphinxstylestrong{phi} (\sphinxstyleemphasis{array\_like}) \textendash{} The phi (angular) values of the points after transformation.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{cartesian\_to\_spherical\_3d() (in module Backend.coordinate\_system\_transformation)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Backend.coordinate_system_transformation:Backend.coordinate_system_transformation.cartesian_to_spherical_3d}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Backend.coordinate\_system\_transformation.}}\sphinxbfcode{\sphinxupquote{cartesian\_to\_spherical\_3d}}}{\emph{x}, \emph{y}, \emph{z}}{}
Convert cartesian points to cylindrical points.

Convert cartesian coordinate points in 3D to cylindrical coordinate points
in 3D. This function uses the notation convention of ISO 80000-2:2009 and
its related successors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The x values of the points to be transformed.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The y values of the points to be transformed.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{z}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The z values of the points to be transformed.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{r} (\sphinxstyleemphasis{array\_like}) \textendash{} The rho (radial) values of the points after transformation.

\item {} 
\sphinxstylestrong{theta} (\sphinxstyleemphasis{array\_like}) \textendash{} The theta (azimuthal angle) values of the points after the
transformation.

\item {} 
\sphinxstylestrong{phi} (\sphinxstyleemphasis{array\_like}) \textendash{} The phi (polar angle) values of the points after the transformation.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{cylindrical\_to\_cartesian\_3d() (in module Backend.coordinate\_system\_transformation)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Backend.coordinate_system_transformation:Backend.coordinate_system_transformation.cylindrical_to_cartesian_3d}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Backend.coordinate\_system\_transformation.}}\sphinxbfcode{\sphinxupquote{cylindrical\_to\_cartesian\_3d}}}{\emph{rho}, \emph{phi}, \emph{z}}{}
Convert cylindrical points to cartesian points.

Convert cylindrical coordinate points in 3D to cartesian coordinate points
in 3D. This function uses the notation convention of ISO 80000-2:2009 and
its related successors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rho}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The rho values of the points to be transformed.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{phi}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The phi values of the points to be transformed.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{z}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The z values of the points to be transformed.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{x} (\sphinxstyleemphasis{array\_like}) \textendash{} The x values of the points after transformation.

\item {} 
\sphinxstylestrong{y} (\sphinxstyleemphasis{array\_like}) \textendash{} The y values of the points after transformation.

\item {} 
\sphinxstylestrong{z} (\sphinxstyleemphasis{array\_like}) \textendash{} The z values of the points after transformation.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{cylindrical\_to\_spherical\_3d() (in module Backend.coordinate\_system\_transformation)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Backend.coordinate_system_transformation:Backend.coordinate_system_transformation.cylindrical_to_spherical_3d}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Backend.coordinate\_system\_transformation.}}\sphinxbfcode{\sphinxupquote{cylindrical\_to\_spherical\_3d}}}{\emph{rho}, \emph{phi}, \emph{z}}{}
Convert cylindrical points to spherical points.

Convert cylindrical coordinate points in 3D to spherical coordinate points
in 3D. This function uses the notation convention of ISO 80000-2:2009 and
its related successors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rho}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The rho values of the points to be transformed.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{phi}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The phi values of the points to be transformed.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{z}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The z values of the points to be transformed.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{r} (\sphinxstyleemphasis{array\_like}) \textendash{} The rho (radial) values of the points after transformation.

\item {} 
\sphinxstylestrong{theta} (\sphinxstyleemphasis{array\_like}) \textendash{} The theta (azimuthal angle) values of the points after the
transformation.

\item {} 
\sphinxstylestrong{phi} (\sphinxstyleemphasis{array\_like}) \textendash{} The phi (polar angle) values of the points after the transformation.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{polar\_to\_cartesian\_2d() (in module Backend.coordinate\_system\_transformation)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Backend.coordinate_system_transformation:Backend.coordinate_system_transformation.polar_to_cartesian_2d}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Backend.coordinate\_system\_transformation.}}\sphinxbfcode{\sphinxupquote{polar\_to\_cartesian\_2d}}}{\emph{rho}, \emph{phi}}{}
Convert polar points to cartesian points.

Convert polar coordinate points in 2D to cartesian coordinate points in 2D.
This function uses the notation convention of ISO 80000-2:2009 and its
related successors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rho}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The rho values of the points to be transformed.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{phi}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The phi values of the points to be transformed.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{x} (\sphinxstyleemphasis{array\_like}) \textendash{} The x values of the points after transformation.

\item {} 
\sphinxstylestrong{y} (\sphinxstyleemphasis{array\_like}) \textendash{} The y values of the points after transformation.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{spherical\_to\_cartesian\_3d() (in module Backend.coordinate\_system\_transformation)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Backend.coordinate_system_transformation:Backend.coordinate_system_transformation.spherical_to_cartesian_3d}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Backend.coordinate\_system\_transformation.}}\sphinxbfcode{\sphinxupquote{spherical\_to\_cartesian\_3d}}}{\emph{r}, \emph{theta}, \emph{phi}}{}
Convert spherical points to cartesian points.

Convert spherical coordinate points in 3D to cartesian coordinate points
in 3D. This function uses the notation convention of ISO 80000-2:2009 and
its related successors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{r}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The r values of the points to be transformed.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{theta}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The theta values of the points to be transformed.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{phi}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The phi values of the points to be transformed.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{x} (\sphinxstyleemphasis{array\_like}) \textendash{} The x values of the points after transformation.

\item {} 
\sphinxstylestrong{y} (\sphinxstyleemphasis{array\_like}) \textendash{} The y values of the points after transformation.

\item {} 
\sphinxstylestrong{z} (\sphinxstyleemphasis{array\_like}) \textendash{} The z values of the points after transformation.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{spherical\_to\_cylindrical\_3d() (in module Backend.coordinate\_system\_transformation)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Backend.coordinate_system_transformation:Backend.coordinate_system_transformation.spherical_to_cylindrical_3d}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Backend.coordinate\_system\_transformation.}}\sphinxbfcode{\sphinxupquote{spherical\_to\_cylindrical\_3d}}}{\emph{r}, \emph{theta}, \emph{phi}}{}
Convert cylindrical points to cartesian points.

Convert cylindrical coordinate points in 3D to cartesian coordinate points
in 3D. This function uses the notation convention of ISO 80000-2:2009 and
its related successors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{r}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The r values of the points to be transformed.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{theta}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The theta values of the points to be transformed.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{phi}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The phi values of the points to be transformed.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{rho} (\sphinxstyleemphasis{array\_like}) \textendash{} The rho values of the points after transformation.

\item {} 
\sphinxstylestrong{phi} (\sphinxstyleemphasis{array\_like}) \textendash{} The phi (angular) values of the points after transformation.

\item {} 
\sphinxstylestrong{z} (\sphinxstyleemphasis{array\_like}) \textendash{} The z values of the points after transformation.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{Backend.electromagnetic\_field\_polarization module}
\label{\detokenize{Backend.electromagnetic_field_polarization:module-Backend.electromagnetic_field_polarization}}\label{\detokenize{Backend.electromagnetic_field_polarization:backend-electromagnetic-field-polarization-module}}\label{\detokenize{Backend.electromagnetic_field_polarization::doc}}\index{Backend.electromagnetic\_field\_polarization (module)}
This file deals with the functions regarding polarization and the
relationship between the electric and magnetic fields.
\index{Stokes\_parameters\_from\_field() (in module Backend.electromagnetic\_field\_polarization)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Backend.electromagnetic_field_polarization:Backend.electromagnetic_field_polarization.Stokes_parameters_from_field}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Backend.electromagnetic\_field\_polarization.}}\sphinxbfcode{\sphinxupquote{Stokes\_parameters\_from\_field}}}{\emph{E\_i}, \emph{E\_j}, \emph{percent\_polarized=1}, \emph{chi=0}}{}
Returns Stokes parameters based off non-circularly polarized light.

This function returns the Stokes parameters based off a given
electric field vector.

Technically it can handle circularly polarized light, the value that
must be given is chi, the angle between the semi-major axis of the
polarization ellipse and the line segment connecting between two points
on the ellipse and the semi-major and semi-minor axes. See note {[}1{]}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{E\_i}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The component of the electric field in the i-hat direction.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{E\_j}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The component of the electric field in the j-hat direction.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{percent\_polarized}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} The percent of the EM wave that is polarized. It should not be too
far off the value of 1.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{chi}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The parameter for circularly polarized light.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{I} (\sphinxstyleemphasis{ndarray}) \textendash{} The first Stokes parameter, equivalent to S\_0. The intensity of the
light.

\item {} 
\sphinxstylestrong{Q} (\sphinxstyleemphasis{ndarray}) \textendash{} The second Stokes parameter, equivalent to S\_1. The x,y polarization
aspect.

\item {} 
\sphinxstylestrong{U} (\sphinxstyleemphasis{ndarray}) \textendash{} The third Stokes parameter, equivalent to S\_2. The a,b (45 deg off set
of x,y) polarization aspect.

\item {} 
\sphinxstylestrong{V} (\sphinxstyleemphasis{ndarray}) \textendash{} The fourth Stokes parameter, equivalent to S\_3. The circular
polarization aspect.

\end{itemize}


\end{description}\end{quote}
\paragraph{Notes}

{[}1{]}  This function’s notation is based on the following diagram.
\sphinxurl{https://en.wikipedia.org/wiki/File:Polarisation\_ellipse2.svg}

{[}2{]} The equations for Stoke’s parameters used is from the following: \sphinxurl{https://en.wikipedia.org/wiki/Stokes\_parameters\#Definitions}.

\end{fulllineitems}

\index{angle\_from\_Stokes\_parameters() (in module Backend.electromagnetic\_field\_polarization)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Backend.electromagnetic_field_polarization:Backend.electromagnetic_field_polarization.angle_from_Stokes_parameters}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Backend.electromagnetic\_field\_polarization.}}\sphinxbfcode{\sphinxupquote{angle\_from\_Stokes\_parameters}}}{\emph{Q}, \emph{U}}{}
Given Stoke parameters Q,U, return the angle of polarization.

This function returns an angle of polarization in radians based on the
values of two stoke parameters. The angle is signed.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Q}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The second Stokes parameter, equivalent to S\_1. The x,y polarization
aspect.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{U}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The third Stokes parameter, equivalent to S\_2. The a,b (45 deg off set
of x,y) polarization aspect.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{angle} \textendash{} The angle of the polarization corresponding to the given Q and U value
pairs. The angle array is parallel to the Q and U array\_like inputs.

\item[{Return type}] \leavevmode
ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{electric\_to\_magnetic() (in module Backend.electromagnetic\_field\_polarization)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Backend.electromagnetic_field_polarization:Backend.electromagnetic_field_polarization.electric_to_magnetic}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Backend.electromagnetic\_field\_polarization.}}\sphinxbfcode{\sphinxupquote{electric\_to\_magnetic}}}{\emph{E\_i}, \emph{E\_j}, \emph{normalize=False}}{}
Convert a 2D electric field vector set to a magnetic field set.

This function takes the electric field that would normally be seen
in a polarization ellipse and converts it to the magnetic field
vectors. This function returns a perpendicular vector of the
magnetic field, perserving the magnitude.

In two dimensions, there are always two vectors perpendicular to a vector.
Or one vector with positive and negative magnitude. In three, there are
infinitely many, so it is much harder to give a good vector.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{E\_i}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The component of the electric field in the i-hat direction.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{E\_j}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The component of the electric field in the j-hat direction.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{normalize}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool; optional}}) \textendash{} If True, then the returned E field vector components are of a unitary
vector. Default is False.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{B\_i} (\sphinxstyleemphasis{ndarray}) \textendash{} The component of the magnetic field in the i-hat direction.

\item {} 
\sphinxstylestrong{B\_j} (\sphinxstyleemphasis{ndarray}) \textendash{} The component of the magnetic field in the j-hat direction.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{magnetic\_to\_electric() (in module Backend.electromagnetic\_field\_polarization)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Backend.electromagnetic_field_polarization:Backend.electromagnetic_field_polarization.magnetic_to_electric}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Backend.electromagnetic\_field\_polarization.}}\sphinxbfcode{\sphinxupquote{magnetic\_to\_electric}}}{\emph{B\_i}, \emph{B\_j}, \emph{normalize=False}}{}
Convert a 2D magnetic field vector set to a electric field set.

This function takes the magnetic field that would normally be seen
in a polarization ellipse and converts it to the electric field
vectors. This function returns a perpendicular vector of the
magnetic field, perserving the magnitude.

In two dimensions, there are always two vectors perpendicular to a vector.
Or one vector with positive and negative magnitude. In three, there are
infinitely many, so it is much harder to give a good vector.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{B\_i}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The component of the magnetic field in the i-hat direction.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{B\_j}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The component of the magnetic field in the j-hat direction.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{normalize}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool; optional}}) \textendash{} If true, then the returned E field vector components are of a unitary
vector. Default is False.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{E\_i} (\sphinxstyleemphasis{ndarray}) \textendash{} The component of the electric field in the i-hat direction.

\item {} 
\sphinxstylestrong{E\_j} (\sphinxstyleemphasis{ndarray}) \textendash{} The component of the electric field in the j-hat direction.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{Backend.plotting\_customization module}
\label{\detokenize{Backend.plotting_customization:module-Backend.plotting_customization}}\label{\detokenize{Backend.plotting_customization:backend-plotting-customization-module}}\label{\detokenize{Backend.plotting_customization::doc}}\index{Backend.plotting\_customization (module)}\index{shiftedColorMap() (in module Backend.plotting\_customization)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Backend.plotting_customization:Backend.plotting_customization.shiftedColorMap}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Backend.plotting\_customization.}}\sphinxbfcode{\sphinxupquote{shiftedColorMap}}}{\emph{cmap}, \emph{start=0}, \emph{midpoint=0.5}, \emph{stop=1.0}, \emph{name='shiftedcmap'}}{}
Modifies the scaling and zero point of Colormap

Function to offset the “center” of a colormap. Useful for
data with a negative min and positive max and you want the
middle of the colormap’s dynamic range to be at zero.

Adapted from: \sphinxurl{https://stackoverflow.com/questions/7404116/defining-the-midpoint-of-a-colormap-in-matplotlib}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cmap}} (\sphinxstyleliteralemphasis{\sphinxupquote{The matplotlib colormap to be altered}}) \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{start}} (\sphinxstyleliteralemphasis{\sphinxupquote{Offset from lowest point in the colormap's range.}}) \textendash{} Defaults to 0.0 (no lower offset). Should be between
0.0 and \sphinxtitleref{midpoint}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{midpoint}} (\sphinxstyleliteralemphasis{\sphinxupquote{The new center of the colormap. Defaults to}}) \textendash{} 0.5 (no shift). Should be between 0.0 and 1.0. In
general, this should be  1 - vmax / (vmax + abs(vmin))
For example if your data range from -15.0 to +5.0 and
you want the center of the colormap at 0.0, \sphinxtitleref{midpoint}
should be set to  1 - 5/(5 + 15)) or 0.75

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{stop}} (\sphinxstyleliteralemphasis{\sphinxupquote{Offset from highest point in the colormap's range.}}) \textendash{} Defaults to 1.0 (no upper offset). Should be between
\sphinxtitleref{midpoint} and 1.0.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{newcmap}

\item[{Return type}] \leavevmode
The new matplotlib colormap.

\end{description}\end{quote}

\end{fulllineitems}

\index{zeroedColorMap() (in module Backend.plotting\_customization)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Backend.plotting_customization:Backend.plotting_customization.zeroedColorMap}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Backend.plotting\_customization.}}\sphinxbfcode{\sphinxupquote{zeroedColorMap}}}{\emph{cmap}, \emph{min\_val}, \emph{max\_val}, \emph{name='shiftedcmap'}}{}
Adapts {\hyperref[\detokenize{Backend.plotting_customization:Backend.plotting_customization.shiftedColorMap}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{shiftedColorMap()}}}}} such that it is centered at zero.

This function is a thin wrapper around the previous function such that
the midpoint is automatically set to zero.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cmap}} (\sphinxstyleliteralemphasis{\sphinxupquote{The matplotlib colormap to be altered}}) \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{start}} (\sphinxstyleliteralemphasis{\sphinxupquote{Offset from lowest point in the colormap's range.}}) \textendash{} Defaults to 0.0 (no lower offset). Should be between
0.0 and \sphinxtitleref{midpoint}.
should be set to  1 - 5/(5 + 15)) or 0.75

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{stop}} (\sphinxstyleliteralemphasis{\sphinxupquote{Offset from highest point in the colormap's range.}}) \textendash{} Defaults to 1.0 (no upper offset). Should be between
\sphinxtitleref{midpoint} and 1.0.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{newcmap}

\item[{Return type}] \leavevmode
The new matplotlib colormap.

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{Backend.table\_interpolation module}
\label{\detokenize{Backend.table_interpolation:module-Backend.table_interpolation}}\label{\detokenize{Backend.table_interpolation:backend-table-interpolation-module}}\label{\detokenize{Backend.table_interpolation::doc}}\index{Backend.table\_interpolation (module)}
This file contains an entire list of functions that would interpolate
a table of values into a numerical approximation of a function. Although
it cannot be an analytical function, these functions attempt to return an
function which would mimic such analytical functions by extrapolating tables.
\index{funt\_interpolate\_scalar\_table() (in module Backend.table\_interpolation)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Backend.table_interpolation:Backend.table_interpolation.funt_interpolate_scalar_table}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Backend.table\_interpolation.}}\sphinxbfcode{\sphinxupquote{funt\_interpolate\_scalar\_table}}}{\emph{x\_array}, \emph{y\_array}, \emph{z\_array}, \emph{ans\_array}, \emph{interp\_method}}{}
Generate functional interpolation of a scalar table.

This function takes a table of x,y,z points which correspond to some scalar
answer and attempts to interpolate to generate a function which would
allow for the computation of the scalar at any arbitrary x,y,z point.

Parallel array representation of the able is assumed.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The x values of the scalar table.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The y values of the scalar table.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{z\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The z values of the scalar table.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ans\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The scalar answers of the table.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{interpolated\_scalar\_function} \textendash{} The numerical approximation to the generalized function.

\item[{Return type}] \leavevmode
function

\end{description}\end{quote}

\end{fulllineitems}

\index{funt\_interpolate\_vector\_table() (in module Backend.table\_interpolation)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Backend.table_interpolation:Backend.table_interpolation.funt_interpolate_vector_table}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Backend.table\_interpolation.}}\sphinxbfcode{\sphinxupquote{funt\_interpolate\_vector\_table}}}{\emph{x\_array}, \emph{y\_array}, \emph{z\_array}, \emph{x\_ans\_array}, \emph{y\_ans\_array}, \emph{z\_ans\_array}, \emph{interp\_method}}{}
Generate functional interpolation of a scalar table.

This function takes a table of x,y,z points which correspond to some scalar
answer and attempts to interpolate to generate a function which would
allow for the computation of the scalar at any arbitrary x,y,z point.

Parallel array representation of the able is assumed.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The x values of the scalar table.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The y values of the scalar table.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{z\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The z values of the scalar table.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x\_ans\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The x component of the answer vector.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y\_ans\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The y component of the answer vector.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{z\_ans\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The z component of the answer vector.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{interpolated\_vector\_function} \textendash{} The numerical approximation to the generalized function.

\item[{Return type}] \leavevmode
function

\end{description}\end{quote}

\end{fulllineitems}



\subsection{Module contents}
\label{\detokenize{Backend:module-Backend}}\label{\detokenize{Backend:module-contents}}\index{Backend (module)}

\section{Robustness package}
\label{\detokenize{Robustness:robustness-package}}\label{\detokenize{Robustness::doc}}

\subsection{Submodules}
\label{\detokenize{Robustness:submodules}}

\subsubsection{Robustness.exception module}
\label{\detokenize{Robustness.exception:module-Robustness.exception}}\label{\detokenize{Robustness.exception:robustness-exception-module}}\label{\detokenize{Robustness.exception::doc}}\index{Robustness.exception (module)}\index{AstronomyError}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Robustness.exception:Robustness.exception.AstronomyError}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{Robustness.exception.}}\sphinxbfcode{\sphinxupquote{AstronomyError}}}{\emph{message}}{}
Bases: \sphinxhref{https://docs.python.org/3/library/exceptions.html\#Exception}{\sphinxcode{\sphinxupquote{Exception}}}

An error to be used if some of the programs executed are trying to
do something that is nonsensical in the context of astronomy.

\end{fulllineitems}

\index{InputError}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Robustness.exception:Robustness.exception.InputError}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{Robustness.exception.}}\sphinxbfcode{\sphinxupquote{InputError}}}{\emph{message}}{}
Bases: \sphinxhref{https://docs.python.org/3/library/exceptions.html\#Exception}{\sphinxcode{\sphinxupquote{Exception}}}

An error to be used when the input from a user is incorrect.

\end{fulllineitems}

\index{OutputError}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Robustness.exception:Robustness.exception.OutputError}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{Robustness.exception.}}\sphinxbfcode{\sphinxupquote{OutputError}}}{\emph{message}}{}
Bases: \sphinxhref{https://docs.python.org/3/library/exceptions.html\#Exception}{\sphinxcode{\sphinxupquote{Exception}}}

An error to be used when the output is grossly unexpected.

\end{fulllineitems}

\index{ShapeError}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Robustness.exception:Robustness.exception.ShapeError}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{Robustness.exception.}}\sphinxbfcode{\sphinxupquote{ShapeError}}}{\emph{message}}{}
Bases: \sphinxhref{https://docs.python.org/3/library/exceptions.html\#Exception}{\sphinxcode{\sphinxupquote{Exception}}}

An error to be used when the dimensions or sizes of an array is incorrect.

\end{fulllineitems}

\index{TerminateError}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Robustness.exception:Robustness.exception.TerminateError}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{Robustness.exception.}}\sphinxbfcode{\sphinxupquote{TerminateError}}}{\emph{message}}{}
Bases: \sphinxhref{https://docs.python.org/3/library/exceptions.html\#BaseException}{\sphinxcode{\sphinxupquote{BaseException}}}

A very serious error that should override the try-except blocks
that are written.

\end{fulllineitems}



\subsubsection{Robustness.input\_parsing module}
\label{\detokenize{Robustness.input_parsing:module-Robustness.input_parsing}}\label{\detokenize{Robustness.input_parsing:robustness-input-parsing-module}}\label{\detokenize{Robustness.input_parsing::doc}}\index{Robustness.input\_parsing (module)}
The purpose of this function is that inputs are parsed correctly.
\index{user\_equation\_parse() (in module Robustness.input\_parsing)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Robustness.input_parsing:Robustness.input_parsing.user_equation_parse}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Robustness.input\_parsing.}}\sphinxbfcode{\sphinxupquote{user\_equation\_parse}}}{\emph{user\_eq\_input}, \emph{variables}}{}
Convert input implicit equation into a function.

This function returns a functional form of a user’s input expression.
Only standard python math functions are to be used, and nothing else.
The functional form will be in return f(x), for the user inputs some string
for f(x). Variables is a string tuple that contains the list of variables
expected in the equation parse.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{user\_eq\_input}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{function}}) \textendash{} This is the wanted string or function to be converted. If it is a
function, there is simple verification before passing it back.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{variables}} (\sphinxstyleliteralemphasis{\sphinxupquote{tuple of strings}}) \textendash{} This is the symbols within the equation for parsing as the input (e.g.
the \sphinxcode{\sphinxupquote{x}} and \sphinxcode{\sphinxupquote{y}} in \sphinxcode{\sphinxupquote{f(x,y)}})

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{function} \textendash{} A callable function that executes the mathematical expression given in
the string. The order of parameters from variables are kept.

\item[{Return type}] \leavevmode
function

\item[{Raises}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{DangerWarning : Warning} \textendash{} This is used because the eval() function is used in this code.

\item {} 
\sphinxstyleemphasis{TerminateError : BaseException} \textendash{} This is done if the verification of the continuation of the program
fails.

\end{itemize}

\end{description}\end{quote}
\paragraph{Notes}

This function does use the eval function and excessive precautions are
used.

\end{fulllineitems}



\subsubsection{Robustness.validation module}
\label{\detokenize{Robustness.validation:module-Robustness.validation}}\label{\detokenize{Robustness.validation:robustness-validation-module}}\label{\detokenize{Robustness.validation::doc}}\index{Robustness.validation (module)}\index{validate\_boolean\_array() (in module Robustness.validation)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Robustness.validation:Robustness.validation.validate_boolean_array}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Robustness.validation.}}\sphinxbfcode{\sphinxupquote{validate\_boolean\_array}}}{\emph{boolean\_array\_input}, \emph{shape=None}, \emph{size=None}, \emph{deep\_validate=False}}{}
The purpose of this function is to validate that the boolean
array is valid. The shape and size of the array can be optionally
tested.

deep\_validate instructs the program to loop over every element
array and validate it in turn.

\end{fulllineitems}

\index{validate\_boolean\_value() (in module Robustness.validation)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Robustness.validation:Robustness.validation.validate_boolean_value}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Robustness.validation.}}\sphinxbfcode{\sphinxupquote{validate\_boolean\_value}}}{\emph{boolean\_value\_input}}{}
The purpose of this function is to validate that a boolean value
input is valid.

\end{fulllineitems}

\index{validate\_float\_array() (in module Robustness.validation)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Robustness.validation:Robustness.validation.validate_float_array}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Robustness.validation.}}\sphinxbfcode{\sphinxupquote{validate\_float\_array}}}{\emph{float\_array\_input}, \emph{shape=None}, \emph{size=None}, \emph{deep\_validate=False}, \emph{greater\_than=None}, \emph{less\_than=None}}{}
The purpose of this function is to validate that the float array is
valid. The shape and size of the array can be optionally tested.

deep\_validate instructs the program to loop over every element array and
validate it in turn.

\end{fulllineitems}

\index{validate\_float\_value() (in module Robustness.validation)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Robustness.validation:Robustness.validation.validate_float_value}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Robustness.validation.}}\sphinxbfcode{\sphinxupquote{validate\_float\_value}}}{\emph{float\_value\_input}, \emph{greater\_than=None}, \emph{less\_than=None}}{}
The purpose of this function is to validate that a float value is valid.
The value, its range (either greater than or less than a number) may
also be tested. This function will bark if the value is greater than
less\_than or less than greater\_than.

\end{fulllineitems}

\index{validate\_function\_call() (in module Robustness.validation)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Robustness.validation:Robustness.validation.validate_function_call}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Robustness.validation.}}\sphinxbfcode{\sphinxupquote{validate\_function\_call}}}{\emph{input\_function}, \emph{n\_parameters=None}}{}
Check if the input function is a valid callable function.

\end{fulllineitems}

\index{validate\_int\_array() (in module Robustness.validation)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Robustness.validation:Robustness.validation.validate_int_array}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Robustness.validation.}}\sphinxbfcode{\sphinxupquote{validate\_int\_array}}}{\emph{int\_array\_input}, \emph{shape=None}, \emph{size=None}, \emph{deep\_validate=False}, \emph{non\_zero=None}, \emph{greater\_than=None}, \emph{less\_than=None}}{}
The purpose of this function is to validate that the integer array is
valid. The shape and size of the array can be optionally tested.

deep\_validate instructs the program to loop over every element array and
validate it in turn.

\end{fulllineitems}

\index{validate\_int\_value() (in module Robustness.validation)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Robustness.validation:Robustness.validation.validate_int_value}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Robustness.validation.}}\sphinxbfcode{\sphinxupquote{validate\_int\_value}}}{\emph{int\_value\_input}, \emph{non\_zero=None}, \emph{greater\_than=None}, \emph{less\_than=None}}{}
The purpose of this function is to validate that a int value is valid.
The value, its range (either greater than or less than a number) may
also be tested. This function will bark if the value is greater than
less\_than or less than greater\_than. It can also be tested if it is
non-zero (true for non-zero, false for zero passes).

\end{fulllineitems}

\index{validate\_list() (in module Robustness.validation)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Robustness.validation:Robustness.validation.validate_list}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Robustness.validation.}}\sphinxbfcode{\sphinxupquote{validate\_list}}}{\emph{input\_list}, \emph{length=None}}{}
The purpose of this function is to validate that a list is valid.

\end{fulllineitems}

\index{validate\_string() (in module Robustness.validation)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Robustness.validation:Robustness.validation.validate_string}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Robustness.validation.}}\sphinxbfcode{\sphinxupquote{validate\_string}}}{\emph{input\_string}, \emph{length=None}, \emph{contain\_substr=None}}{}
The purpose of this function is to determine if a string is valid. The
length of the string can also be tested. If the string contains a substring
can also be tested. Due to oddities of strings, this function may return
back false errors.

\end{fulllineitems}

\index{validate\_tuple() (in module Robustness.validation)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Robustness.validation:Robustness.validation.validate_tuple}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Robustness.validation.}}\sphinxbfcode{\sphinxupquote{validate\_tuple}}}{\emph{input\_tuple}, \emph{length=None}}{}
The purpose of this function is to validate that a tuple is valid.

\end{fulllineitems}



\subsubsection{Robustness.warning module}
\label{\detokenize{Robustness.warning:module-Robustness.warning}}\label{\detokenize{Robustness.warning:robustness-warning-module}}\label{\detokenize{Robustness.warning::doc}}\index{Robustness.warning (module)}\index{AstronomyWarning}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Robustness.warning:Robustness.warning.AstronomyWarning}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{Robustness.warning.}}\sphinxbfcode{\sphinxupquote{AstronomyWarning}}}{\emph{message}}{}
Bases: {\hyperref[\detokenize{Robustness.warning:Robustness.warning.PhysicalityWarning}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Robustness.warning.PhysicalityWarning}}}}}

A warning to be used when the current program is doing something a bit
risky or something that would not make normal sense in astronomical terms.

\end{fulllineitems}

\index{DangerWarning}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Robustness.warning:Robustness.warning.DangerWarning}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{Robustness.warning.}}\sphinxbfcode{\sphinxupquote{DangerWarning}}}{\emph{message}}{}
Bases: \sphinxhref{https://docs.python.org/3/library/exceptions.html\#Warning}{\sphinxcode{\sphinxupquote{Warning}}}

A warning to be used when some input or output is dangerous for the
system or program itself and may be disastrous with unexpected inputs.

\end{fulllineitems}

\index{InputWarning}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Robustness.warning:Robustness.warning.InputWarning}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{Robustness.warning.}}\sphinxbfcode{\sphinxupquote{InputWarning}}}{\emph{message}}{}
Bases: \sphinxhref{https://docs.python.org/3/library/exceptions.html\#Warning}{\sphinxcode{\sphinxupquote{Warning}}}

A warning to be used when the values of some item is incorrect, but is
fixed within the program.

\end{fulllineitems}

\index{OutputWarning}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Robustness.warning:Robustness.warning.OutputWarning}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{Robustness.warning.}}\sphinxbfcode{\sphinxupquote{OutputWarning}}}{\emph{message}}{}
Bases: \sphinxhref{https://docs.python.org/3/library/exceptions.html\#Warning}{\sphinxcode{\sphinxupquote{Warning}}}

A warning to be used when the values of an output may not use all of the
inputs given, or that it might become unexpected because of bugs.

\end{fulllineitems}

\index{PhysicalityWarning}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Robustness.warning:Robustness.warning.PhysicalityWarning}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{Robustness.warning.}}\sphinxbfcode{\sphinxupquote{PhysicalityWarning}}}{\emph{message}}{}
Bases: \sphinxhref{https://docs.python.org/3/library/exceptions.html\#Warning}{\sphinxcode{\sphinxupquote{Warning}}}

A warning to be used when the current program is doing something that does
not make sense in real life.

\end{fulllineitems}

\index{PhysicsWarning}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Robustness.warning:Robustness.warning.PhysicsWarning}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{Robustness.warning.}}\sphinxbfcode{\sphinxupquote{PhysicsWarning}}}{\emph{message}}{}
Bases: {\hyperref[\detokenize{Robustness.warning:Robustness.warning.PhysicalityWarning}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Robustness.warning.PhysicalityWarning}}}}}

A warning to be used when the current program is doing something a bit
risky or something that would not make normal sense in physics terms.

\end{fulllineitems}

\index{TimeWarning}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Robustness.warning:Robustness.warning.TimeWarning}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{Robustness.warning.}}\sphinxbfcode{\sphinxupquote{TimeWarning}}}{\emph{message}}{}
Bases: \sphinxhref{https://docs.python.org/3/library/exceptions.html\#ResourceWarning}{\sphinxcode{\sphinxupquote{ResourceWarning}}}

A warning to be used when some computation or flag might take a long time
to compute.

\end{fulllineitems}

\index{kyubey\_warning() (in module Robustness.warning)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Robustness.warning:Robustness.warning.kyubey_warning}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Robustness.warning.}}\sphinxbfcode{\sphinxupquote{kyubey\_warning}}}{\emph{warn\_class}, \emph{message}, \emph{stacklevel=2}, \emph{input\_halt=False}}{}
General warning for the Robustness module/function package. If the warning
is serious enough (like a DangerWarning), then force the user to ensure
the continuation of the program.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{warn\_class}} (\sphinxcode{\sphinxupquote{warning}} object) \textendash{} The warning which to submit.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{message}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} The warning message.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{stacklevel}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} The stack level call that the warning goes back to.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{input\_halt}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool; optional}}) \textendash{} If the warning requires user input to continue, this is true. Defaults
to false.

\end{itemize}

\item[{Raises}] \leavevmode
{\hyperref[\detokenize{Robustness.exception:Robustness.exception.TerminateError}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{TerminateError}}}}} in the event of the input halt failing.

\end{description}\end{quote}

\end{fulllineitems}



\subsection{Module contents}
\label{\detokenize{Robustness:module-Robustness}}\label{\detokenize{Robustness:module-contents}}\index{Robustness (module)}

\section{data\_systematization module}
\label{\detokenize{data_systematization:module-data_systematization}}\label{\detokenize{data_systematization:data-systematization-module}}\label{\detokenize{data_systematization::doc}}\index{data\_systematization (module)}
This file contains the methods needed to convert from a non-standard or
accepted data type into a more usable datatype by this module.
\index{InterpolationTable (class in data\_systematization)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_systematization:data_systematization.InterpolationTable}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{data\_systematization.}}\sphinxbfcode{\sphinxupquote{InterpolationTable}}}{\emph{x\_values}, \emph{y\_values}, \emph{z\_values}, \emph{classification}, \emph{scalar\_ans=None}, \emph{x\_vector\_ans=None}, \emph{y\_vector\_ans=None}, \emph{z\_vector\_ans=None}}{}
Bases: \sphinxhref{https://docs.python.org/3/library/functions.html\#object}{\sphinxcode{\sphinxupquote{object}}}

A class representing either a scalar or vector table.

If a lookup table is to be used instead of a function for the model
observing method, it is required to standardize the information given
by the user’s lookup table, as is the purpose of this class.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x\_values}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The values of the x points for the table. Array must be parallel
with y\_values and z\_values along with the scalar/vector answer.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y\_values}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The values of the x points for the table. Array must be parallel
with x\_values and z\_values along with the scalar/vector answer.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{z\_values}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The values of the x points for the table. Array must be parallel
with x\_values and y\_values along with the scalar/vector answer.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{classification}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} 
The classification of this table, either as a scalar lookup table
or a vector lookup table. Should be one of:
\begin{itemize}
\item {} 
’scalar’   A scalar based lookup table.

\item {} 
’vector’   A vector based lookup table.

\end{itemize}


\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{scalar\_ans}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{\{for \textbar{} classification == 'scalar'\}}}) \textendash{} The scalar answers to the (x,y,z) point given by the input values.
Must be parallel with x\_values, y\_values, and z\_values. Ignored if
classification == ‘vector’.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x\_vector\_ans}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{\{for \textbar{} classification == 'vector'\}}}) \textendash{} The x component of the answer vector that exists at the point
(x,y,z) given by the input values. Must be parallel with x\_values,
y\_values, and z\_values along with other components. Ignored if
classification == ‘scalar’

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y\_vector\_ans}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{\{for \textbar{} classification == 'vector'\}}}) \textendash{} The y component of the answer vector that exists at the point
(x,y,z) given by the input values. Must be parallel with x\_values,
y\_values, and z\_values along with other components. Ignored if
classification == ‘scalar’

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{z\_vector\_ans}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{\{for \textbar{} classification == 'vector'\}}}) \textendash{} The z component of the answer vector that exists at the point
(x,y,z) given by the input values. Must be parallel with x\_values,
y\_values, and z\_values along with other components. Ignored if
classification == ‘scalar’

\end{itemize}

\end{description}\end{quote}


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{numerical\_function()~:~function~\{returns~\textbar{}~function\}}}}
Returns a function which is an interface to a numerical approximation
interpolation of the data points given in the lookup table.
Automatically detects if it is a scalar function or vector function.

\end{fulllineitems}

\paragraph{Methods}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{data_systematization:data_systematization.InterpolationTable.numerical_function}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{numerical\_function}}}}}({[}interp\_method{]})
&
Generate a numerical function from the lookup table.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}
\index{\_\_init\_\_() (data\_systematization.InterpolationTable method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_systematization:data_systematization.InterpolationTable.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{x\_values}, \emph{y\_values}, \emph{z\_values}, \emph{classification}, \emph{scalar\_ans=None}, \emph{x\_vector\_ans=None}, \emph{y\_vector\_ans=None}, \emph{z\_vector\_ans=None}}{}
A class representing either a scalar or vector table.

If a lookup table is to be used instead of a function for the model
observing method, it is required to standardize the information given
by the user’s lookup table, as is the purpose of this class.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x\_values}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The values of the x points for the table. Array must be parallel
with y\_values and z\_values along with the scalar/vector answer.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y\_values}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The values of the x points for the table. Array must be parallel
with x\_values and z\_values along with the scalar/vector answer.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{z\_values}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The values of the x points for the table. Array must be parallel
with x\_values and y\_values along with the scalar/vector answer.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{classification}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} 
The classification of this table, either as a scalar lookup table
or a vector lookup table. Should be one of:
\begin{itemize}
\item {} 
’scalar’   A scalar based lookup table.

\item {} 
’vector’   A vector based lookup table.

\end{itemize}


\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{scalar\_ans}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{\{for \textbar{} classification == 'scalar'\}}}) \textendash{} The scalar answers to the (x,y,z) point given by the input values.
Must be parallel with x\_values, y\_values, and z\_values. Ignored if
classification == ‘vector’.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x\_vector\_ans}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{\{for \textbar{} classification == 'vector'\}}}) \textendash{} The x component of the answer vector that exists at the point
(x,y,z) given by the input values. Must be parallel with x\_values,
y\_values, and z\_values along with other components. Ignored if
classification == ‘scalar’

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y\_vector\_ans}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{\{for \textbar{} classification == 'vector'\}}}) \textendash{} The y component of the answer vector that exists at the point
(x,y,z) given by the input values. Must be parallel with x\_values,
y\_values, and z\_values along with other components. Ignored if
classification == ‘scalar’

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{z\_vector\_ans}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{\{for \textbar{} classification == 'vector'\}}}) \textendash{} The z component of the answer vector that exists at the point
(x,y,z) given by the input values. Must be parallel with x\_values,
y\_values, and z\_values along with other components. Ignored if
classification == ‘scalar’

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{numerical\_function() (data\_systematization.InterpolationTable method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{data_systematization:data_systematization.InterpolationTable.numerical_function}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{numerical\_function}}}{\emph{interp\_method='linear'}}{}
Generate a numerical function from the lookup table.

This function creates a functional interface of the data from a lookup
table. It interpolates values that are not in the table to return
what Scipy thinks is the best value.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{interp\_method}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
The method of interpolation to be used. Must be one of the
following strings:
\begin{itemize}
\item {} 
’nearest’

\item {} 
’linear’, default

\item {} 
’cubic’

\end{itemize}


\item[{Returns}] \leavevmode
\sphinxstylestrong{numeric\_function} \textendash{} The numerical interpolation function that attempts to best
replicate the table.

\item[{Return type}] \leavevmode
function

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{density\_field\_functions module}
\label{\detokenize{density_field_functions:module-density_field_functions}}\label{\detokenize{density_field_functions:density-field-functions-module}}\label{\detokenize{density_field_functions::doc}}\index{density\_field\_functions (module)}
This document contains a large amount of the implemented density field
functions for ease of access.


\section{magnetic\_field\_functions\_2d module}
\label{\detokenize{magnetic_field_functions_2d:module-magnetic_field_functions_2d}}\label{\detokenize{magnetic_field_functions_2d:magnetic-field-functions-2d-module}}\label{\detokenize{magnetic_field_functions_2d::doc}}\index{magnetic\_field\_functions\_2d (module)}
This document highlights 2d versions of magnetic field functions. Thus, these
functions take in 2 parameters, the x,y values or rho,phi values, and return
the u,v vector components of the given magnetic field
\index{circular\_magnetic\_field\_cart\_2d() (in module magnetic\_field\_functions\_2d)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{magnetic_field_functions_2d:magnetic_field_functions_2d.circular_magnetic_field_cart_2d}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{magnetic\_field\_functions\_2d.}}\sphinxbfcode{\sphinxupquote{circular\_magnetic\_field\_cart\_2d}}}{\emph{x, y, center={[}0, 0{]}, mag\_function=\textless{}function \textless{}lambda\textgreater{}\textgreater{}}}{}
Compute the cartesian magnetic field vectors of a circular field.

The circular magnetic field is radially symmetric. This function returns
the values of the components of a magnetic field given some point(s) x,y.
The center of the circular magnetic field can be redefined.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The x values of the points for magnetic field computation.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The y values of the points for magnetic field computation.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{center}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like; optional}}) \textendash{} The center of the circular magnetic field function, passed as an
array \sphinxcode{\sphinxupquote{{[}x0,y0{]}}}. Defaults to \sphinxcode{\sphinxupquote{{[}0,0{]}}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mag\_function}} (function \sphinxcode{\sphinxupquote{f(r)}}; optional) \textendash{} The value of the magnitude of the vector field at some radius from
the center. Default is \sphinxcode{\sphinxupquote{f(r) = 1/r**2}}.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{Bfield\_x} (\sphinxstyleemphasis{ndarray}) \textendash{} The x component of the magnetic field at the given points. Order
is perserved.

\item {} 
\sphinxstylestrong{Bfield\_y} (\sphinxstyleemphasis{ndarray}) \textendash{} The y component of the magnetic field at the given points. Order
is perserved.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{hourglass\_magnetic\_field\_cart\_2d() (in module magnetic\_field\_functions\_2d)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{magnetic_field_functions_2d:magnetic_field_functions_2d.hourglass_magnetic_field_cart_2d}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{magnetic\_field\_functions\_2d.}}\sphinxbfcode{\sphinxupquote{hourglass\_magnetic\_field\_cart\_2d}}}{\emph{r, z, h, k\_array, disk\_radius, uniform\_B0, center={[}0, 0{]}}}{}
Equation for hourglass magnetic fields given by Ewertowshi \& Basu 2013.

This function is the two dimensional version of the equations given by
Ewertowshi \& Basu 2013. This projects the values of the three dimensional
form to the r-z plane in cylindrical coordinates. In practice, r,z can be
mapped to x,y. The center can also be changed.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{r}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The input values of the radial direction for the equation.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{z}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The input values of the polar direction for the equation.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{h}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} A free parameter as dictated by the paper.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{k\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The list of k coefficient values for the summation in Eq 45.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{disk\_radius}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} The radius of the protoplanetary disk. Relevent for the hourglass
magnetic field generated by this paper.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{uniform\_B0}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} The magnitude of the background magnetic field.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{center}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like; optional}}) \textendash{} The center of the hourglass shaped magnetic field function, passed
as an array \sphinxcode{\sphinxupquote{{[}r0,z0{]}}}. Defaults to \sphinxcode{\sphinxupquote{{[}0,0{]}}}

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{Bfield\_r} (\sphinxstyleemphasis{ndarray}) \textendash{} The value of the magnetic field in the r-axial direction.

\item {} 
\sphinxstylestrong{Bfield\_z} (\sphinxstyleemphasis{ndarray}) \textendash{} The value of the magnetic field in the z-axial direction.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\section{magnetic\_field\_functions\_3d module}
\label{\detokenize{magnetic_field_functions_3d:module-magnetic_field_functions_3d}}\label{\detokenize{magnetic_field_functions_3d:magnetic-field-functions-3d-module}}\label{\detokenize{magnetic_field_functions_3d::doc}}\index{magnetic\_field\_functions\_3d (module)}
This document highlights 2d versions of magnetic field functions. Thus, these
functions take in 2 parameters, the x,y values or rho,phi values, and return
the u,v vector components of the given magnetic field
\index{circular\_magnetic\_field\_cart\_3d() (in module magnetic\_field\_functions\_3d)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{magnetic_field_functions_3d:magnetic_field_functions_3d.circular_magnetic_field_cart_3d}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{magnetic\_field\_functions\_3d.}}\sphinxbfcode{\sphinxupquote{circular\_magnetic\_field\_cart\_3d}}}{\emph{x, y, z, center={[}0, 0, 0{]}, mag\_function=\textless{}function \textless{}lambda\textgreater{}\textgreater{}, curl\_axis='z', **kwargs}}{}
Compute the cartesian magnetic field vectors of a circular field.

The circular magnetic field is radially symmetric. This function
returns the values of the components of a magnetic field given some
point(s) x,y,z. The center of the circular magnetic field can be
redefined. The axis of symmetry can also be redefined.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The x values of the points for magnetic field computation.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The y values of the points for the magnetic field computation

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{z}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The z values of the points for magnetic field computation.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{center}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like; optional}}) \textendash{} The center of the circular magnetic field function, passed as an
array \sphinxcode{\sphinxupquote{{[}x0,y0{]}}}. Default is \sphinxcode{\sphinxupquote{{[}0,0,0{]}}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mag\_function}} (function \sphinxcode{\sphinxupquote{f(r)}}; optional) \textendash{} The value of the magnitude of the vector field at some radius from
the center. Default is \sphinxcode{\sphinxupquote{f(r) = 1/r**2}}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{curl\_axis}} (\sphinxstyleliteralemphasis{\sphinxupquote{string; optional}}) \textendash{} The specified axis that the magnetic field curls around. Default is
the \sphinxcode{\sphinxupquote{z}} axis.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{Bfield\_x} (\sphinxstyleemphasis{ndarray}) \textendash{} The x component of the magnetic field at the given points. Order
is perserved.

\item {} 
\sphinxstylestrong{Bfield\_y} (\sphinxstyleemphasis{ndarray}) \textendash{} The y component of the magnetic field at the given points. Order
is perserved.

\item {} 
\sphinxstylestrong{Bfield\_z} (\sphinxstyleemphasis{ndarray}) \textendash{} The z component of the magnetic field at the given points. Order
is perserved.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{hourglass\_magnetic\_field\_cart\_3d() (in module magnetic\_field\_functions\_3d)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{magnetic_field_functions_3d:magnetic_field_functions_3d.hourglass_magnetic_field_cart_3d}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{magnetic\_field\_functions\_3d.}}\sphinxbfcode{\sphinxupquote{hourglass\_magnetic\_field\_cart\_3d}}}{\emph{x, y, z, h, k\_array, disk\_radius, uniform\_B0, center={[}0, 0, 0{]}, **kwargs}}{}
Equation for hourglass magnetic fields given by Ewertowshi \& Basu 2013.

This function is the three dimensional version of the equations given by
Ewertowshi \& Basu 2013. This function assumes, as the paper does, that the
magnetic field is invariant with respect to phi.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The input values of the x direction for the equation.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The input values of the y direction for the equation.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{z}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The input values of the z direction for the equation.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{h}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} A free parameter as dictated by the paper.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{k\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The list of k coefficient values for the summation in Eq 45.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{disk\_radius}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} The radius of the protoplanetary disk. Relevent for the hourglass
magnetic field generated by this paper.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{uniform\_B0}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} The magnitude of the background magnetic field.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{center}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like; optional}}) \textendash{} The center of the hourglass shaped magnetic field function, passed
as an array \sphinxcode{\sphinxupquote{{[}r0,phi0,z0{]}}}. Defaults to \sphinxcode{\sphinxupquote{{[}0,0,0{]}}}

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{Bfield\_x} (\sphinxstyleemphasis{ndarray}) \textendash{} The value of the magnetic field in the x-axial direction.

\item {} 
\sphinxstylestrong{Bfield\_y} (\sphinxstyleemphasis{ndarray}) \textendash{} The value of the magnetic field in the y-axial direction.

\item {} 
\sphinxstylestrong{Bfield\_z} (\sphinxstyleemphasis{ndarray}) \textendash{} The value of the magnetic field in the z-axial direction.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{hourglass\_magnetic\_field\_cyln\_3d() (in module magnetic\_field\_functions\_3d)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{magnetic_field_functions_3d:magnetic_field_functions_3d.hourglass_magnetic_field_cyln_3d}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{magnetic\_field\_functions\_3d.}}\sphinxbfcode{\sphinxupquote{hourglass\_magnetic\_field\_cyln\_3d}}}{\emph{rho, phi, z, h, k\_array, disk\_radius, uniform\_B0, center={[}0, 0, 0{]}, **kwargs}}{}
Equation for hourglass magnetic fields given by Ewertowshi \& Basu 2013.

This function is the three dimensional version of the equations given by
Ewertowshi \& Basu 2013. This function assumes, as the paper does, that the
magnetic field is invariant with respect to phi.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rho}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The input values of the radial direction for the equation.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{phi}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The input values of the polar angle for the equation.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{z}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The input values of the polar direction for the equation.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{h}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} A free parameter as dictated by the paper.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{k\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The list of k coefficient values for the summation in Eq 45.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{disk\_radius}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} The radius of the protoplanetary disk. Relevent for the hourglass
magnetic field generated by this paper.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{uniform\_B0}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} The magnitude of the background magnetic field.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{center}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The center of the hourglass shaped magnetic field function, passed
as an array \sphinxcode{\sphinxupquote{{[}r0,phi0,z0{]}}}. Defaults to \sphinxcode{\sphinxupquote{{[}0,0,0{]}}}

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{Bfield\_rho} (\sphinxstyleemphasis{ndarray}) \textendash{} The value of the magnetic field in the rho-axial direction.

\item {} 
\sphinxstylestrong{Bfield\_phi} (\sphinxstyleemphasis{ndarray}) \textendash{} The value of the magnetic field in the phi-axial direction.

\item {} 
\sphinxstylestrong{Bfield\_z} (\sphinxstyleemphasis{ndarray}) \textendash{} The value of the magnetic field in the z-axial direction.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{linear\_combination\_magnetic\_field() (in module magnetic\_field\_functions\_3d)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{magnetic_field_functions_3d:magnetic_field_functions_3d.linear_combination_magnetic_field}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{magnetic\_field\_functions\_3d.}}\sphinxbfcode{\sphinxupquote{linear\_combination\_magnetic\_field}}}{\emph{field\_functions}, \emph{contributions}, \emph{**kwargs}}{}
This function handles the linear combination of functions.

This function, when given a list of magnetic field functions, their contributions, and the required arguments, will return another function which is based on the linear combination (as determined by contribution) of the given functions. The linear combination of the magnetic fields relies on the superposition principle.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{field\_functions}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The array of magnetic field functions that are to be used. Must be an
array\_like of callable functions.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{contributions}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The float value array of the contribution of each magnetic fields. May
either be based on percentage, or a multiplicative factor.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} (\sphinxstyleliteralemphasis{\sphinxupquote{arguments}}) \textendash{} A dictionary (or explicitly typed out list) of parameters that are required for the other field functions.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{monopole\_magnetic\_field\_cart\_3d() (in module magnetic\_field\_functions\_3d)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{magnetic_field_functions_3d:magnetic_field_functions_3d.monopole_magnetic_field_cart_3d}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{magnetic\_field\_functions\_3d.}}\sphinxbfcode{\sphinxupquote{monopole\_magnetic\_field\_cart\_3d}}}{\emph{x, y, z, center={[}0, 0, 0{]}, mag\_function=\textless{}function \textless{}lambda\textgreater{}\textgreater{}, **kwargs}}{}
This is a monopole magnetic field, extending radially with zero curl.

This function gives a description of a magnetic field extending radially
according to some magnitude function (as a function of radius). The
point of radiance (the center of the field) can be adjusted as needed.

Note that this is currently an impossible shape for a magnetic field as
determined by Maxwell’s equations.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The x values of the input points.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The y values of the input points.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{z}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The z values of the input points.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{center}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The center of the magnetic field.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mag\_function}} (\sphinxstyleliteralemphasis{\sphinxupquote{function}}) \textendash{} The magnitude of the magnetic fields as a function of radius.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{Bfield\_x} (\sphinxstyleemphasis{ndarray}) \textendash{} The x component of the magnetic field.

\item {} 
\sphinxstylestrong{Bfield\_y} (\sphinxstyleemphasis{ndarray}) \textendash{} The y component of the magnetic field.

\item {} 
\sphinxstylestrong{Bfield\_z} (\sphinxstyleemphasis{ndarray}) \textendash{} The z component of the magnetic field.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{monopole\_magnetic\_field\_sphr\_3d() (in module magnetic\_field\_functions\_3d)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{magnetic_field_functions_3d:magnetic_field_functions_3d.monopole_magnetic_field_sphr_3d}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{magnetic\_field\_functions\_3d.}}\sphinxbfcode{\sphinxupquote{monopole\_magnetic\_field\_sphr\_3d}}}{\emph{r, theta, phi, center={[}0, 0, 0{]}, mag\_function=\textless{}function \textless{}lambda\textgreater{}\textgreater{}, **kwargs}}{}
This is a monopole magnetic field, extending radially with zero curl.

This function gives a description of a magnetic field extending radially
according to some magnitude function (as a function of radius). The
point of radiance (the center of the field) can be adjusted as needed.

Note that this is currently an impossible shape for a magnetic field as
determined by Maxwell’s equations.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{r}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The radial component of the input points.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{theta}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The polar angle component of the input points.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{phi}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The azimuthal angle component of the input points.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{center}} (\sphinxstyleliteralemphasis{\sphinxupquote{array\_like}}) \textendash{} The center point of the magnetic field.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mag\_function}} (\sphinxstyleliteralemphasis{\sphinxupquote{function}}) \textendash{} The measured magnitude of the magnetic field as a function of \sphinxcode{\sphinxupquote{r}}.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{Bfield\_r} (\sphinxstyleemphasis{ndarray}) \textendash{} The radial component of the magnetic field at the given points.

\item {} 
\sphinxstylestrong{Bfield\_theta} (\sphinxstyleemphasis{ndarray}) \textendash{} The polar angle component of the magnetic field at the given points.

\item {} 
\sphinxstylestrong{Bfeild\_phi} (\sphinxstyleemphasis{ndarray}) \textendash{} The azimuthal angle component of the magnetic field at the given points.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\section{model\_observing module}
\label{\detokenize{model_observing:module-model_observing}}\label{\detokenize{model_observing:model-observing-module}}\label{\detokenize{model_observing::doc}}\index{model\_observing (module)}
Model observing, this module is built to simulate actual observing. The
object is known, and given sight parameters, the data is given. In particular,
these functions actually give the values of terms derived from the object
model also provided.
\index{ObservingRun (class in model\_observing)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{model_observing:model_observing.ObservingRun}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{model\_observing.}}\sphinxbfcode{\sphinxupquote{ObservingRun}}}{\emph{observe\_target}, \emph{sightline}, \emph{field\_of\_view}}{}
Bases: \sphinxhref{https://docs.python.org/3/library/functions.html\#object}{\sphinxcode{\sphinxupquote{object}}}

Execute a mock observing run of an object.

This class is the main model observations of an object. Taking a
central sightline and the field of view, it then gives back a set of
plots, similar to those that an observer would see after data reduction.

The class itself does the computation in its methods, returning back
a heatmap/contour object plot from the observing depending on the method.
\index{observe\_target (model\_observing.ObservingRun.self attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{model_observing:model_observing.ObservingRun.self.observe_target}}\pysigline{\sphinxcode{\sphinxupquote{self.}}\sphinxbfcode{\sphinxupquote{observe\_target}}}
{\hyperref[\detokenize{model_observing:model_observing.ProtostarModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ProtostarModel}}}}} object \textendash{} The model target for simulated observing. Conceptually, the object
that the telescope observes.

\end{fulllineitems}

\index{sightline (model\_observing.ObservingRun.self attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{model_observing:model_observing.ObservingRun.self.sightline}}\pysigline{\sphinxcode{\sphinxupquote{self.}}\sphinxbfcode{\sphinxupquote{sightline}}}
{\hyperref[\detokenize{model_observing:model_observing.Sightline}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Sightline}}}}} object \textendash{} The primary sightline that is used for the model observing,
conceptually where the telescope is aimed at.

\end{fulllineitems}

\index{field\_of\_view (model\_observing.ObservingRun.self attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{model_observing:model_observing.ObservingRun.self.field_of_view}}\pysigline{\sphinxcode{\sphinxupquote{self.}}\sphinxbfcode{\sphinxupquote{field\_of\_view}}}
\sphinxstyleemphasis{float} \textendash{} The field of view value of the observation, given as the length
of the observing chart.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{Stokes\_parameter\_contours()~:~function~\{returns~\textbar{}~ndarray,ndarray\}}}}
Compute the value of Stoke parameters at random sightlines from the
primary sightline and plot them. Returns the values that was used
to plot.

\end{fulllineitems}

\paragraph{Methods}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{model_observing:model_observing.ObservingRun.Stokes_parameter_contours}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Stokes\_parameter\_contours}}}}}({[}plot\_parameters, …{]})
&
This function produces a contour plot of the stoke values.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}
\index{Stokes\_parameter\_contours() (model\_observing.ObservingRun method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{model_observing:model_observing.ObservingRun.Stokes_parameter_contours}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Stokes\_parameter\_contours}}}{\emph{plot\_parameters=True}, \emph{n\_axial\_samples=25}}{}
This function produces a contour plot of the stoke values.

This function generates a large number of random sightlines to
traceout contour information of the of the fields. From
there, is creates and returns a contour plot.

The values of the intensity, I, the two polarization values, Q,U, and
the polarization intensity, hypt(Q,U) is plotted.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{plot\_parameters}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool; optional}}) \textendash{} A boolean value to specify if the user wanted the parameters to be
plotted.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_axial\_samples}} (\sphinxstyleliteralemphasis{\sphinxupquote{int; optional}}) \textendash{} The number of points along one RA or DEC axis to be sampled. The
resulting sample is a mesh n**2 between the bounds. Default is 25.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{ra\_dec\_array} (\sphinxstyleemphasis{tuple(ndarray)}) \textendash{} This is a tuple of the values of the RA and DEC of the random
sightlines (arranged in parallel arrays).

\item {} 
\sphinxstylestrong{stokes\_parameters} (\sphinxstyleemphasis{tuple(ndarray)}) \textendash{} This is a tuple of ndarrays of the stoke parameters calculated by
the random sightlines.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_init\_\_() (model\_observing.ObservingRun method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{model_observing:model_observing.ObservingRun.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{observe\_target}, \emph{sightline}, \emph{field\_of\_view}}{}
Doing an observing run.

Create an observing run object, compiling the primary sightline and
the field of view.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{observe\_target}} ({\hyperref[\detokenize{model_observing:model_observing.ProtostarModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ProtostarModel}}}}} object) \textendash{} This is the object to be observed.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sightline}} (\sphinxstyleliteralemphasis{\sphinxupquote{Sightline object}}) \textendash{} This is the primary sightline, in essence, where the telescope
is pointing in this simulation.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{field\_of\_view}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}) \textendash{} The width of the sky segment that is being observed. Must be in
radians. Applies to both RA and DEC evenly for a square image.
Seen range is {}`{}` (RA,DEC) \(\pm\) field\_of\_view/2 {\color{red}\bfseries{}{}`{}`}.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ProtostarModel (class in model\_observing)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{model_observing:model_observing.ProtostarModel}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{model\_observing.}}\sphinxbfcode{\sphinxupquote{ProtostarModel}}}{\emph{coordinates}, \emph{cloud\_model}, \emph{magnetic\_field\_model}, \emph{density\_model=None}, \emph{polarization\_model=None}, \emph{zeros\_guess\_count=100}}{}
Bases: \sphinxhref{https://docs.python.org/3/library/functions.html\#object}{\sphinxcode{\sphinxupquote{object}}}

This is an object that represents a model of an object in space. It
contains all the required functions and parameters associated with
one of the objects that would be observed for polarimetry data.
\index{coordinates (model\_observing.ProtostarModel.self attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{model_observing:model_observing.ProtostarModel.self.coordinates}}\pysigline{\sphinxcode{\sphinxupquote{self.}}\sphinxbfcode{\sphinxupquote{coordinates}}}
Astropy \sphinxhref{http://docs.astropy.org/en/stable/api/astropy.coordinates.SkyCoord.html\#astropy.coordinates.SkyCoord}{\sphinxcode{\sphinxupquote{SkyCoord}}} object \textendash{} This is the coordinates of the object that this class defines.

\end{fulllineitems}

\index{cloud\_model (model\_observing.ProtostarModel.self attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{model_observing:model_observing.ProtostarModel.self.cloud_model}}\pysigline{\sphinxcode{\sphinxupquote{self.}}\sphinxbfcode{\sphinxupquote{cloud\_model}}}
\sphinxstyleemphasis{function} \textendash{} This is an implicit function (or a numerical approximation thereof) of
the shape of the protostar cloud.

\end{fulllineitems}

\index{magnetic\_field (model\_observing.ProtostarModel.self attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{model_observing:model_observing.ProtostarModel.self.magnetic_field}}\pysigline{\sphinxcode{\sphinxupquote{self.}}\sphinxbfcode{\sphinxupquote{magnetic\_field}}}
\sphinxstyleemphasis{function} \textendash{} This is an implicit function (or a numerical approximation thereof) of
the shape of the magnetic field.

\end{fulllineitems}

\index{density\_model (model\_observing.ProtostarModel.self attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{model_observing:model_observing.ProtostarModel.self.density_model}}\pysigline{\sphinxcode{\sphinxupquote{self.}}\sphinxbfcode{\sphinxupquote{density\_model}}}
\sphinxstyleemphasis{function} \textendash{} This is an implicit function (or a numerical approximation thereof) of
the shape of the density model of the cloud.

\end{fulllineitems}

\index{polarization\_model (model\_observing.ProtostarModel.self attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{model_observing:model_observing.ProtostarModel.self.polarization_model}}\pysigline{\sphinxcode{\sphinxupquote{self.}}\sphinxbfcode{\sphinxupquote{polarization\_model}}}
\sphinxstyleemphasis{function} \textendash{} This is an implicit function (or a numerical approximation thereof) of
the polarization model of the cloud.

\end{fulllineitems}

\index{\_\_init\_\_() (model\_observing.ProtostarModel method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{model_observing:model_observing.ProtostarModel.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{coordinates}, \emph{cloud\_model}, \emph{magnetic\_field\_model}, \emph{density\_model=None}, \emph{polarization\_model=None}, \emph{zeros\_guess\_count=100}}{}
Object form of a model object to be observed.

This is the object representation of an object in the sky. The
required terms are present.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coordinates}} (Astropy \sphinxhref{http://docs.astropy.org/en/stable/api/astropy.coordinates.SkyCoord.html\#astropy.coordinates.SkyCoord}{\sphinxcode{\sphinxupquote{SkyCoord}}} object) \textendash{} These are the coordinates of the observation object. It is up
to the user to put as complete information as possible.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cloud\_model}} (\sphinxstyleliteralemphasis{\sphinxupquote{function}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{string}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}) \textendash{} An implicit equation of the cloud. The origin of this equation
must also be the coordinate specified by self.coordinates. Must
be cartesian in the form \sphinxcode{\sphinxupquote{f(x,y,z) = 0}}, for the function or
string is \sphinxcode{\sphinxupquote{f(x,y,z)}}. The x-axis is always aligned with a
telescope as it is the same as a telescope’s r-axis.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{magnetic\_field\_model}} (function or {\hyperref[\detokenize{data_systematization:data_systematization.InterpolationTable}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{InterpolationTable}}}}}) \textendash{} A function that, given a single point in cartesian space, will
return the value of the magnitude of the magnetic field’s three
orthogonal vectors in xyz-space. If an interpolation table is
given, a numerical approximation function will be used instead.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{density\_model}} (function or string, or {\hyperref[\detokenize{data_systematization:data_systematization.InterpolationTable}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{InterpolationTable}}}}}; optional) \textendash{} A function that, given a point in cartesian space, will return
a value pertaining to the density of the gas/dust within at that
point. Defaults to uniform. If an interpolation table is
given, a numerical approximation function will be used instead.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{polarization\_model}} (function, string, float or {\hyperref[\detokenize{data_systematization:data_systematization.InterpolationTable}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{InterpolationTable}}}}}; optional) \textendash{} This is the percent of polarization of the light. Either given as
a function (or string representing a function) \sphinxcode{\sphinxupquote{f(x,y,z)}}, or
as a constant float value. Default is uniform value of 1. If an
interpolation table is given, a numerical approximation function
will be used instead.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{zeros\_guess\_count}} (\sphinxstyleliteralemphasis{\sphinxupquote{int; optional}}) \textendash{} This value stipulates how many spread out test points there should
be when finding sightline intersection points. A higher number
should be used for complex shapes. Defaults at 100.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Sightline (class in model\_observing)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{model_observing:model_observing.Sightline}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{model\_observing.}}\sphinxbfcode{\sphinxupquote{Sightline}}}{\emph{right\_ascension}, \emph{declination}, \emph{SkyCoord\_object=None}}{}
Bases: \sphinxhref{https://docs.python.org/3/library/functions.html\#object}{\sphinxcode{\sphinxupquote{object}}}

This is a sightline. It contains the information for a given sightline
through space. The sightline is always given by the RA and DEC values.

The notation for the accepted values of RA and DEC is found in the
Astropy module’s \sphinxhref{http://docs.astropy.org/en/stable/api/astropy.coordinates.SkyCoord.html\#astropy.coordinates.SkyCoord}{\sphinxcode{\sphinxupquote{SkyCoord}}} class.
\index{coordinates (model\_observing.Sightline.self attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{model_observing:model_observing.Sightline.self.coordinates}}\pysigline{\sphinxcode{\sphinxupquote{self.}}\sphinxbfcode{\sphinxupquote{coordinates}}}
Astropy \sphinxhref{http://docs.astropy.org/en/stable/api/astropy.coordinates.SkyCoord.html\#astropy.coordinates.SkyCoord}{\sphinxcode{\sphinxupquote{SkyCoord}}} object. \textendash{} This is the sky coordinates of the sightline.

\end{fulllineitems}

\index{sightline\_parameters() (model\_observing.Sightline method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{model_observing:model_observing.Sightline.sightline_parameters}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{sightline\_parameters}}}{\emph{) : function (returns \textbar{} ndarray}, \emph{ndarray}}{}
This method returns back both the sightline’s center and slopes for
an actual geometrical representation of the line. Converting from
the equatorial coordinate system to the cartesian coordinate system.

\end{fulllineitems}

\paragraph{Methods}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{model_observing:model_observing.Sightline.sightline_parameters}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{sightline\_parameters}}}}}()
&
This function returns the sightline linear parameters.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}
\index{\_\_init\_\_() (model\_observing.Sightline method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{model_observing:model_observing.Sightline.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{right\_ascension}, \emph{declination}, \emph{SkyCoord\_object=None}}{}
Initialization of a sightline.

The creates the sightline’s main parameters, the defineing elements
of the sightline is the location that it is throughout space. This
is a specific wrapper around \sphinxhref{http://docs.astropy.org/en/stable/api/astropy.coordinates.SkyCoord.html\#astropy.coordinates.SkyCoord}{\sphinxcode{\sphinxupquote{SkyCoord}}}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{right\_ascension}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} The right ascension value for the sightline. This term must be
formatted in the Astropy \sphinxhref{http://docs.astropy.org/en/stable/api/astropy.coordinates.SkyCoord.html\#astropy.coordinates.SkyCoord}{\sphinxcode{\sphinxupquote{SkyCoord}}} format: \sphinxcode{\sphinxupquote{00h00m00.00s}}.
For the values of the seconds are decimal and may extend to any
precision.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{declination}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} The declination value for the sightline. This term must be
formatted in the Astropy \sphinxhref{http://docs.astropy.org/en/stable/api/astropy.coordinates.SkyCoord.html\#astropy.coordinates.SkyCoord}{\sphinxcode{\sphinxupquote{SkyCoord}}} format: \sphinxcode{\sphinxupquote{\(\pm\)00d00m00.00s}}.
For the values of the seconds are decimal and may extend to any
precision.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Skycord\_object}} (\sphinxhref{http://docs.astropy.org/en/stable/api/astropy.coordinates.SkyCoord.html\#astropy.coordinates.SkyCoord}{\sphinxcode{\sphinxupquote{SkyCoord}}} object; optional) \textendash{} It may be easier to also just pass an Astropy
\sphinxhref{http://docs.astropy.org/en/stable/api/astropy.coordinates.SkyCoord.html\#astropy.coordinates.SkyCoord}{\sphinxcode{\sphinxupquote{SkyCoord}}} object in
general. The other strings are ignored if it is successful.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{sightline\_parameters() (model\_observing.Sightline method)}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{sightline\_parameters}}}{}{}
This function returns the sightline linear parameters.

The sightline is by definition always parallel to the x-axis
of the object to be observed. The plane of the sky is the yz-plane
of the object. This function returns first the central defining
point, then the deltas for the equation.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{sightline\_center} (\sphinxstyleemphasis{ndarray}) \textendash{} This returns a cartsian point based on the approximation
that, if the x-axis and the r-axis are the same of cartesian
and spherical cordinates, then so too are the yz-plane and the
theta-phi plane.

\item {} 
\sphinxstylestrong{sightline\_slopes} (\sphinxstyleemphasis{ndarray}) \textendash{} This returns the slopes of the cartesian point values given
by the center. Because of the approximation from above, it is
always {[}1,0,0{]}.

\end{itemize}


\end{description}\end{quote}
\paragraph{Notes}

The coordinates of the sightline in relation to the object are as
follows:
\begin{itemize}
\item {} 
The x-axis of the object is equal to the r-axis of the telescope. Both pointing away from the telescope, deeper into space.

\item {} 
The y-axis of the object is equal to the RA-axis/phi-axis of the

\end{itemize}

telescope, westward (as y increases, RA decreases)
- The z-axis of the object is equal to the DEC-axis of the telescope. It is also equal to the negative of the theta-axis
when it is centered on theta = pi/2. Points north-south of the
telescope.

\end{fulllineitems}


\end{fulllineitems}



\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{b}
\item {\sphinxstyleindexentry{Backend}}\sphinxstyleindexpageref{Backend:\detokenize{module-Backend}}
\item {\sphinxstyleindexentry{Backend.astronomical\_coordinates}}\sphinxstyleindexpageref{Backend.astronomical_coordinates:\detokenize{module-Backend.astronomical_coordinates}}
\item {\sphinxstyleindexentry{Backend.cloud\_line\_integration}}\sphinxstyleindexpageref{Backend.cloud_line_integration:\detokenize{module-Backend.cloud_line_integration}}
\item {\sphinxstyleindexentry{Backend.coordinate\_system\_transformation}}\sphinxstyleindexpageref{Backend.coordinate_system_transformation:\detokenize{module-Backend.coordinate_system_transformation}}
\item {\sphinxstyleindexentry{Backend.electromagnetic\_field\_polarization}}\sphinxstyleindexpageref{Backend.electromagnetic_field_polarization:\detokenize{module-Backend.electromagnetic_field_polarization}}
\item {\sphinxstyleindexentry{Backend.Ewertowski\_Basu\_2013}}\sphinxstyleindexpageref{Backend.Ewertowski_Basu_2013:\detokenize{module-Backend.Ewertowski_Basu_2013}}
\item {\sphinxstyleindexentry{Backend.plotting\_customization}}\sphinxstyleindexpageref{Backend.plotting_customization:\detokenize{module-Backend.plotting_customization}}
\item {\sphinxstyleindexentry{Backend.table\_interpolation}}\sphinxstyleindexpageref{Backend.table_interpolation:\detokenize{module-Backend.table_interpolation}}
\indexspace
\bigletter{d}
\item {\sphinxstyleindexentry{data\_systematization}}\sphinxstyleindexpageref{data_systematization:\detokenize{module-data_systematization}}
\item {\sphinxstyleindexentry{density\_field\_functions}}\sphinxstyleindexpageref{density_field_functions:\detokenize{module-density_field_functions}}
\indexspace
\bigletter{m}
\item {\sphinxstyleindexentry{magnetic\_field\_functions\_2d}}\sphinxstyleindexpageref{magnetic_field_functions_2d:\detokenize{module-magnetic_field_functions_2d}}
\item {\sphinxstyleindexentry{magnetic\_field\_functions\_3d}}\sphinxstyleindexpageref{magnetic_field_functions_3d:\detokenize{module-magnetic_field_functions_3d}}
\item {\sphinxstyleindexentry{model\_observing}}\sphinxstyleindexpageref{model_observing:\detokenize{module-model_observing}}
\indexspace
\bigletter{r}
\item {\sphinxstyleindexentry{Robustness}}\sphinxstyleindexpageref{Robustness:\detokenize{module-Robustness}}
\item {\sphinxstyleindexentry{Robustness.exception}}\sphinxstyleindexpageref{Robustness.exception:\detokenize{module-Robustness.exception}}
\item {\sphinxstyleindexentry{Robustness.input\_parsing}}\sphinxstyleindexpageref{Robustness.input_parsing:\detokenize{module-Robustness.input_parsing}}
\item {\sphinxstyleindexentry{Robustness.validation}}\sphinxstyleindexpageref{Robustness.validation:\detokenize{module-Robustness.validation}}
\item {\sphinxstyleindexentry{Robustness.warning}}\sphinxstyleindexpageref{Robustness.warning:\detokenize{module-Robustness.warning}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}