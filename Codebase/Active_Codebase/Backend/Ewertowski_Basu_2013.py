"""
This file is most of the backend functionality that is required for the 
more important functions within this module that relates to the paper by 
Bartek Ewertowshi and Shantanu Basu on their work in 2013 on "A Mathematical
Model for an Hourglass Magnetic Field".

The functions here are almost explicitly for magnetic field functions.
"""

import numpy as np 
import scipy as sp
import scipy.special as sp_spcl



def bessel_zeros(order, index):
    """Returns a Bessel zero given the function's order and zero index.

    This function is a wrapper around Scipy's Bessel function zero generator.
    For some reason, the Scipy function returns all zeros between the given
    number and the first zero. This function extracts only the wanted zero
    given the index. 
    
    This is for Bessel functions of the first kind.

    Parameters:
    -----------
    order : int
        The integer order of the Bessel function of the first kind.
    index : int
        The zero's index that is desired. 

    Returns:
    --------
    zero : float
        The value of the zero at the given index of the given Bessel function.
    """
    # Basic type checking.
    order = int(order)
    index = int(index)

    # For some reason, scipy wants to return all zeros from 1 to n. This
    # function only wants the last one.
    zero_array = sp_spcl.jn_zeros(order, index)
    zero = zero_array[-1]
    return zero


def Ewer_Basu__eigenvalues(index_m, disk_radius):
    """This is the values of the eigenvalues of some integer index m.

    This computes the eigenvalues (see Equation 28 of Ewer & Basu 2013) of 
    the normalized Green functions for the hourglass magnetic field solution.

    Parameters:
    -----------
    index_m : int
        This is the index of the eigenvalue, it links up to the index of the 
        positive root of a Bessel function of the first kind of order 1.
    disk_radius: float
        The radius of the protoplanetary disk. Relevent for the hourglass
        magnetic field generated by this paper.

    Returns:
    --------
    eigenvalue : float
        The value of the corresponding eigenvalue given the parameters.
    """
    
    # Basic type checking
    index_m = int(index_m)
    disk_radius = float(disk_radius)

    # Compute the Eigenvalue
    eigenvalue = (bessel_zeros(1, index_m)/disk_radius)**2

    return eigenvalue


def Ewer_Basu__B_r(r, z, h, k_array, disk_radius):
    """An implementation of Eq 45 of Ewertiwski & Basu 2013.

    This implements equation 45 of Ewertiwski & Basu 2013. The k_array (values
    of k) determine the number of summation terms that will be computed. The
    value of r is with respect to the cylindrical cordinate system.

    Parameters:
    -----------
    r : array_like
        The input values of the radial direction for the equation.
    z : array_like
        The input values of the polar direction for the equation.
    h : float
        A free parameter as dictated by the paper.
    k_array : array_like
        The list of k coefficient values for the summation in Eq 45.
    disk_radius : float
        The radius of the protoplanetary disk. Relevent for the hourglass
        magnetic field generated by this paper.

    Returns:
    --------
    Bfield_r : ndarray
        The value of the magnetic field in the r-axial direction.
    """
    # Basic type check
    r = np.array(r,dtype=float)
    z = np.array(z,dtype=float)
    h = float(h)
    k_array = np.array(k_array,dtype=float)
    disk_radius = float(np.abs(disk_radius))

    # Shorthand for the squareroot of the eigenvalues. Account for 0 indexing
    def evsq(m): return np.sqrt(Ewer_Basu__eigenvalues(m + 1, disk_radius))
    # Shorthand for bessel function of order 1.
    def bess1(x): return sp_spcl.jv(1, x)
    # Pylint does not like the Scipy complementary error function.
    def _erfc(x): return sp_spcl.erfc(x) # pylint: disable=no-member

    Bfield_r = 0
    for kdex, k_value in enumerate(k_array):
        # Dividing the equation into smaller chunks for readability.
        coefficient = k_value * evsq(kdex) * bess1(evsq(kdex) * r)
        # Left and right erfc functions of the equation, respectively.
        minus_erfc = _erfc((0.5*evsq(kdex)*h) - z/h)
        plus_erfc = _erfc((0.5*evsq(kdex)*h) + z/h)
        # Exponent values
        neg_exp = np.exp(-evsq(kdex) * z)
        pos_exp = np.exp(evsq(kdex) * z)

        Bfield_r = (Bfield_r 
                    + (coefficient * (minus_erfc * neg_exp 
                                      - plus_erfc * pos_exp)))

    return Bfield_r



def Ewer_Basu__B_z(r, z, h, k_array, disk_radius, uniform_B0):
    """An implementation of Eq 46 of Ewertiwski & Basu 2013.

    This implements equation 46 of Ewertiwski & Basu 2013. The k_array (values
    of k) determine the number of summation terms that will be computed. The
    value of r is with respect to the cylindrical cordinate system.

    Parameters:
    -----------
    r : array_like
        The input values of the radial direction for the equation.
    z : array_like
        The input values of the polar direction for the equation.
    h : float
        A free parameter as dictated by the paper.
    k_array : array_like
        The list of k coefficient values for the summation in Eq 45.
    disk_radius : float
        The radius of the protoplanetary disk. Relevent for the hourglass
        magnetic field generated by this paper.
    uniform_B0 : float
        The magnitude of the background magnetic field.

    Returns:
    --------
    Bfield_z : ndarray
        The value of the magnetic field in the z-axial direction.
    """
    # Basic type check
    r = np.array(r,dtype=float)
    z = np.array(z,dtype=float)
    h = float(h)
    k_array = np.array(k_array,dtype=float)
    disk_radius = float(np.abs(disk_radius))
    uniform_B0 = float(uniform_B0)

    # Shorthand for the squareroot of the eigenvalues. Account for 0 indexing.
    def evsq(m): return np.sqrt(Ewer_Basu__eigenvalues(m + 1, disk_radius))
    # Shorthand for bessel function of order 1.
    def bess0(x): return sp_spcl.jv(0, x)
    # Pylint does not like Scipy's complementary error function.
    def _erfc(x): return sp_spcl.erfc(x) # pylint: disable=no-member

    Bfeild_z = 0
    for kdex, k_value in enumerate(k_array):
        # Dividing the equation into smaller chunks for readability.
        coefficient = k_value * evsq(kdex) * bess0(evsq(kdex) * r)
        # Left and right erfc functions of the equation, respectively.
        plus_erfc = _erfc((0.5*evsq(kdex)*h) + z/h)
        minus_erfc = _erfc((0.5*evsq(kdex)*h) - z/h)
        # Exponent values
        pos_exp = np.exp(evsq(kdex) * z)
        neg_exp = np.exp(-evsq(kdex) * z)

        Bfeild_z = (Bfeild_z 
                    + (coefficient * (plus_erfc * pos_exp 
                                      + minus_erfc * neg_exp)))

    return Bfeild_z + uniform_B0
